# Command Enhancements
if [[ $(uname) == 'Linux' ]]; then
  . ~/bin/dotfiles/bash/aliases_linux
elif [[ $(uname) == 'Darwin' ]]; then
  . ~/bin/dotfiles/bash/aliases_mac
fi

# Utility
alias reload='. ~/.bashrc'

# Common
alias md='mkdir -p'
alias s='cd ..'   # up one dir

function take() { 
    mkdir -p "$1"
    cd "$1" 
}

alias e='exit'
alias k9="killall -9"

function killnamed () { 
    ps ax | grep $1 | cut -d ' ' -f 2 | xargs kill 
}

function zipr() {
  zip -r $1.zip $1
}

function find_in_source(){
	 find . -name "*rb" -o -name "*erb" -o -name "*yml" | xargs grep -ni "$1"
}

# Finder
alias o='open . &'
alias ff='open -a Firefox'

# Processes
alias tu='top -o cpu' # cpu
alias tm='top -o vsize' # memory

# Git
alias ungit="find . -name '.git' -exec rm -rf {} \;"
alias gb='git branch'
alias gba='git branch -a'
alias gc='git commit -v'
alias gca='git commit -v -a'

# Commit pending changes and quote all args as message
function gg() { 
    git commit -v -a -m "$*"
}

alias gco='git checkout'
alias gd='git diff'
alias gdm='git diff master'
alias gl='git pull'
alias gnp="git-notpushed"
alias gp='git push'
alias gst='git status'
alias gt='git status'
alias g='git status'
alias eg='mate .git/config'
# Git clone from GitHub
function gch() {
  git clone git://github.com/$USER/$1.git
}

# Quickly clobber a file and checkout
function grf() { 
  rm $1
  git checkout $1 
}
# Call from inside an initialized Git repo, with the name of the repo.
function new-git() {
  ssh git@example.com "mkdir $1.git && cd $1.git && git --bare init"
  git remote add origin git@example.com:$1.git
  git push origin master
  git config branch.master.remote origin
  git config branch.master.merge refs/heads/master
  git config push.default current
}

function push() {
  
  # Defaults
  MINLEN=3
  DIRTY=false
  DEPLOY="deploy"
  REMOTE_REPO = "origin master"
  
  # Check if we have any untracked files
  if git status | grep -q "modified:" 
  then
    DIRTY=true
  fi
  
  # Make sure there is a message with the commit 
  if [ -z "$1" ] && (test $DIRTY == true)
  then
    echo "You must specify a message with your commit"
    return
  elif [ ${#1} -lt $MINLEN ] && (test $DIRTY == true)
  then
    echo "Your message must have at least $MINLEN letters."
    return
  fi
  
  # Commit all the changes by default
  if (test $DIRTY == true)
  then
    echo "Adding new files to Git repository"
    git add .
  
    echo "Commiting to local Git repository"
    git commit -a -m "$1"
    
    # Push changes if a remote repository exists
    if git remote | grep -q "origin"  
    then
      echo "Pushing changes to remote repository"
      git push $REMOTE_REPO
    fi
  fi
  
  # Deploy changes via Capistrano
  if ls | grep -q Capfile 
  then
    cap $DEPLOY
  fi
}

# Text editing

# TextMate
alias m="mate"
#alias ett="mate ."

# mvim
#alias m="mvim"
#alias scrails="screen -c ~/.rails.screen"
# Ruby
alias r="rake"

# Rails
alias reload!='touch tmp/restart.txt'
alias sc='./script/console'
alias sg='./script/generate'
alias sp='./script/plugin'
alias ss='./script/server'
alias tl='tail -f log/*.log'

# Setup a tunnel
function haproxyssh() { 
  ssh -L7997:127.0.0.1:7997 deploy@$1.com 
}

function aiff2mp3() { 
  lame -h -V 0 $1.aif $1.mp3 
}
function wav2mp3() { 
  lame -h -V 0 $1.wav $1.mp3 
}


# XCode
# Analyze release build
alias sx="xcodebuild clean && ~/src/checker-0.146/scan-build -k -V xcodebuild"
# Analyze test build
alias sxt="xcodebuild -target Test clean && ~/src/checker-0.146/scan-build -k -V xcodebuild -target Test"
# Call with -target Foo
function sxx() { 
  xcodebuild $* clean && ~/src/checker-0.146/scan-build -k -V xcodebuild $* 
}

alias ox="open *.xcodeproj"

function parse_git_branch {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
}

alias scrails='screen -c ~/.rails.screen'

function git_diff() {
  git diff --no-ext-diff -w "$@" | mvim -R -
}
