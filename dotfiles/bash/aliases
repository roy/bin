# Command Enhancements
if [[ $(uname) == 'Linux' ]]; then
  . ~/bin/dotfiles/bash/aliases_linux
elif [[ $(uname) == 'Darwin' ]]; then
  . ~/bin/dotfiles/bash/aliases_mac
fi

# Utility
alias reload='. ~/.bashrc'

# Common
alias md='mkdir -p'
alias s='cd ..'   # up one dir

function take() { 
    mkdir -p "$1"
    cd "$1" 
}

alias e='exit'
alias k9="killall -9"

function killnamed () { 
    ps ax | grep $1 | cut -d ' ' -f 2 | xargs kill 
}

function zipr() {
  zip -r $1.zip $1
}

function find_in_source(){
	 find . -name "*rb" -o -name "*erb" -o -name "*yml" | xargs grep -ni "$1"
}

# Finder
alias o='open . &'
alias ff='open -a Firefox'

# Processes
alias tu='top -o cpu' # cpu
alias tm='top -o vsize' # memory

# Git
alias ungit="find . -name '.git' -exec rm -rf {} \;"
alias gb='git branch'
alias gba='git branch -a'
alias gc='git commit -v'
alias gca='git commit -v -a'

# Commit pending changes and quote all args as message
function gg() { 
    git commit -v -a -m "$*"
}

alias gco='git checkout'
alias gd='git diff'
alias gdm='git diff master'
alias gl='git pull'
alias gnp="git-notpushed"
alias gp='git push'
alias gst='git status'
alias gt='git status'
alias g='git status'
alias eg='mate .git/config'
# Git clone from GitHub
function gch() {
  git clone git://github.com/$USER/$1.git
}

# Quickly clobber a file and checkout
function grf() { 
  rm $1
  git checkout $1 
}
# Call from inside an initialized Git repo, with the name of the repo.
function new-git() {
  ssh git@example.com "mkdir $1.git && cd $1.git && git --bare init"
  git remote add origin git@example.com:$1.git
  git push origin master
  git config branch.master.remote origin
  git config branch.master.merge refs/heads/master
  git config push.default current
}

function push() {
  
  # Defaults
  MINLEN=3
  DIRTY=false
  DEPLOY="deploy"
  REMOTE_REPO = "origin master"
  
  # Check if we have any untracked files
  if git status | grep -q "modified:" 
  then
    DIRTY=true
  fi
  
  # Make sure there is a message with the commit 
  if [ -z "$1" ] && (test $DIRTY == true)
  then
    echo "You must specify a message with your commit"
    return
  elif [ ${#1} -lt $MINLEN ] && (test $DIRTY == true)
  then
    echo "Your message must have at least $MINLEN letters."
    return
  fi
  
  # Commit all the changes by default
  if (test $DIRTY == true)
  then
    echo "Adding new files to Git repository"
    git add .
  
    echo "Commiting to local Git repository"
    git commit -a -m "$1"
    
    # Push changes if a remote repository exists
    if git remote | grep -q "origin"  
    then
      echo "Pushing changes to remote repository"
      git push $REMOTE_REPO
    fi
  fi
  
  # Deploy changes via Capistrano
  if ls | grep -q Capfile 
  then
    cap $DEPLOY
  fi
}

# Text editing

# TextMate
alias m="mate"
#alias ett="mate ."

# mvim
#alias m="mvim"
#alias scrails="screen -c ~/.rails.screen"
# Ruby
alias r="rake"

# Rails
function reload!(){
  echo "restarting rails"
  touch tmp/restart.txt
}
alias sc='./script/console'
alias sg='./script/generate'
alias sp='./script/plugin'
alias ss='./script/server'
alias tl='tail -f log/*.log'

# Setup a tunnel
function haproxyssh() { 
  ssh -L7997:127.0.0.1:7997 deploy@$1.com 
}

function aiff2mp3() { 
  lame -h -V 0 $1.aif $1.mp3 
}
function wav2mp3() { 
  lame -h -V 0 $1.wav $1.mp3 
}


# XCode
# Analyze release build
alias sx="xcodebuild clean && ~/src/checker-0.146/scan-build -k -V xcodebuild"
# Analyze test build
alias sxt="xcodebuild -target Test clean && ~/src/checker-0.146/scan-build -k -V xcodebuild -target Test"
# Call with -target Foo
function sxx() { 
  xcodebuild $* clean && ~/src/checker-0.146/scan-build -k -V xcodebuild $* 
}

alias ox="open *.xcodeproj"

function parse_git_branch {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
}
ps1_git()
{
  local branch="" sha1="" line="" attr="" color=0

  shopt -s extglob # Important, for our nice matchers :)

  command -v git >/dev/null 2>&1 || {
    printf " \033[1;37m\033[41m[git not found]\033[m "
    return 0
  }

  branch=$(git symbolic-ref -q HEAD 2>/dev/null)

  (( $? > 0 )) && return 0 # Not in a git repo, no need to continue.

  branch=${branch##refs/heads/}

  # Now we display the branch.
  sha1=$(git rev-parse --short --quiet HEAD)

  case "${branch:-"(no branch)"}" in
   production|prod) attr="1;37m\033[" ; color=41 ;; # red
   master|deploy)   color=31                     ;; # red
   stage|staging)   color=33                     ;; # yellow
   dev|development) color=34                     ;; # blue
   next)            color=36                     ;; # gray
   *)
     if [[ -n "${branch}" ]] ; then # Feature Branch :)
       color=32 # green
     else
       color=0 # reset
     fi
     ;;
  esac

  [[ $color -gt 0 ]] &&
    printf " \033[${attr}${color}m(${branch}$(ps1_git_status):$sha1)\033[0m"
}

ps1_git_status()
{
  local git_status="$(git status 2>/dev/null)"

  [[ "${git_status}" = *deleted* ]]                    && printf "%s" "-"
  [[ "${git_status}" = *Untracked[[:space:]]files:* ]] && printf "%s" "+"
  [[ "${git_status}" = *modified:* ]]                  && printf "%s" "*"
}

ps1_rvm()
{
  command -v rvm-prompt >/dev/null 2>&1 && printf "%s" " $(rvm-prompt) "
}

alias scrails='screen -c ~/.rails.screen'

function git_diff() {
  git diff --no-ext-diff -w "$@" | mvim -R -
}
